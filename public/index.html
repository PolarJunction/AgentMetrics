<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent Metrics Dashboard</title>
  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-card: #1e293b;
      --bg-card-hover: #253346;
      --border-color: #334155;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --color-blue: #60a5fa;
      --color-green: #34d399;
      --color-pink: #f472b6;
      --color-yellow: #fbbf24;
      --shadow: rgba(0,0,0,0.3);
    }

    [data-theme="light"] {
      --bg-primary: #f8fafc;
      --bg-card: #ffffff;
      --bg-card-hover: #f1f5f9;
      --border-color: #e2e8f0;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --text-muted: #94a3b8;
      --shadow: rgba(0,0,0,0.1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 2rem;
      transition: background 0.3s ease, color 0.3s ease;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: 0 auto 2rem;
    }

    h1 {
      text-align: center;
      font-size: 2rem;
      color: var(--color-blue);
    }

    .header-actions {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .theme-toggle {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.5rem;
      cursor: pointer;
      font-size: 1.25rem;
      transition: all 0.2s ease;
    }

    .theme-toggle:hover {
      background: var(--bg-card-hover);
      transform: scale(1.1);
    }

    .export-btn {
      background: var(--color-blue);
      color: #000;
      border: none;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 600;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .export-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px var(--shadow);
    }

    /* Loading Spinner */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }

    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--border-color);
      border-top-color: var(--color-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      max-width: 1200px;
      margin: 0 auto;
    }

    .metric-card {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      border: 1px solid var(--border-color);
      transition: transform 0.2s, box-shadow 0.2s, background 0.3s ease;
    }

    .metric-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px var(--shadow);
    }

    .metric-card.updating {
      animation: pulse 0.3s ease;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }

    .metric-label {
      font-size: 0.875rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .comparison-badge {
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      margin-left: 0.5rem;
    }

    .comparison-badge.positive {
      background: rgba(52, 211, 153, 0.15);
      color: var(--color-green);
    }

    .comparison-badge.negative {
      background: rgba(248, 113, 113, 0.15);
      color: #f87171;
    }

    .trend-indicator {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .trend-up {
      color: var(--color-green);
      background: rgba(52, 211, 153, 0.1);
    }

    .trend-down {
      color: #f87171;
      background: rgba(248, 113, 113, 0.1);
    }

    .trend-neutral {
      color: var(--text-secondary);
      background: rgba(148, 163, 184, 0.1);
    }

    .metric-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--color-blue);
      transition: all 0.3s ease;
    }

    .metric-card:nth-child(2) .metric-value { color: var(--color-green); }
    .metric-card:nth-child(3) .metric-value { color: var(--color-pink); }
    .metric-card:nth-child(4) .metric-value { color: var(--color-yellow); }

    .metric-footer {
      margin-top: 1rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .mock-badge {
      display: inline-block;
      background: #f59e0b;
      color: #000;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .gateway-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
      margin-right: 0.5rem;
    }

    .gateway-indicator.connected {
      background: #10b981;
      color: #fff;
    }

    .gateway-indicator.disconnected {
      background: #6b7280;
      color: #fff;
    }

    .gateway-indicator.error {
      background: #ef4444;
      color: #fff;
    }

    .gateway-indicator::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    /* Charts Section */
    .charts-section {
      max-width: 1200px;
      margin: 2rem auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 1.5rem;
    }

    .chart-card {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      border: 1px solid var(--border-color);
      animation: fadeIn 0.5s ease-out;
      transition: background 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .chart-card:nth-child(1) { animation-delay: 0.1s; }
    .chart-card:nth-child(2) { animation-delay: 0.2s; }
    .chart-card:nth-child(3) { animation-delay: 0.3s; }

    .chart-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 1rem;
    }

    /* Line Chart */
    .line-chart {
      width: 100%;
      height: 150px;
    }

    .line-chart path {
      fill: none;
      stroke: var(--color-blue);
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .line-chart .area {
      fill: url(#lineGradient);
      stroke: none;
    }

    .line-chart .dot {
      fill: var(--color-blue);
      stroke: var(--bg-card);
      stroke-width: 2;
      transition: r 0.2s ease;
    }

    .line-chart .dot:hover {
      r: 6;
    }

    .line-chart .grid-line {
      stroke: var(--border-color);
      stroke-width: 1;
      stroke-dasharray: 3,3;
    }

    .line-chart .axis-label {
      fill: var(--text-muted);
      font-size: 10px;
    }

    /* Heatmap */
    .heatmap {
      display: grid;
      grid-template-columns: repeat(24, 1fr);
      gap: 2px;
    }

    .heatmap-cell {
      aspect-ratio: 1;
      border-radius: 2px;
      transition: transform 0.2s, opacity 0.2s;
      cursor: pointer;
      position: relative;
    }

    .heatmap-cell:hover {
      transform: scale(1.3);
      z-index: 1;
    }

    .heatmap-cell:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--text-primary);
      color: var(--bg-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      white-space: nowrap;
      margin-bottom: 4px;
    }

    .heatmap-label {
      grid-column: span 24;
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: var(--text-muted);
      margin-bottom: 0.25rem;
    }

    .heatmap-row {
      display: contents;
    }

    .heatmap-day {
      font-size: 0.65rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
    }

    /* Bar Chart */
    .bar-chart {
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      height: 120px;
      padding: 1rem 0;
      border-bottom: 1px solid var(--border-color);
    }

    .bar-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .bar {
      width: 40px;
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease-out;
      animation: growUp 0.5s ease-out;
      position: relative;
    }

    .bar:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--text-primary);
      color: var(--bg-primary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      white-space: nowrap;
    }

    @keyframes growUp {
      from { transform: scaleY(0); }
      to { transform: scaleY(1); }
    }

    .bar-label {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .bar-value {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .last-updated {
      text-align: center;
      margin-top: 2rem;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    /* Alert Banner */
    .alert-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      text-align: center;
      font-weight: 600;
      z-index: 1000;
      transform: translateY(-100%);
      transition: transform 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .alert-banner.visible {
      transform: translateY(0);
    }

    .alert-banner.info {
      background: linear-gradient(90deg, #3b82f6, #60a5fa);
      color: #fff;
    }

    .alert-banner.warning {
      background: linear-gradient(90deg, #f59e0b, #fbbf24);
      color: #000;
    }

    .alert-banner.critical {
      background: linear-gradient(90deg, #dc2626, #ef4444);
      color: #fff;
      animation: pulse-critical 1s ease-in-out infinite;
    }

    @keyframes pulse-critical {
      0%, 100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
    }

    .alert-banner .alert-icon {
      font-size: 1.25rem;
    }

    .alert-banner .alert-message {
      flex: 1;
    }

    .alert-banner .alert-dismiss {
      background: rgba(0,0,0,0.2);
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .alert-banner .alert-dismiss:hover {
      background: rgba(0,0,0,0.3);
    }

    /* Alert Panel */
    .alert-panel-toggle {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--color-blue);
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      box-shadow: 0 4px 15px rgba(96, 165, 250, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 100;
    }

    .alert-panel-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(96, 165, 250, 0.5);
    }

    .alert-panel-toggle .alert-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #ef4444;
      color: #fff;
      font-size: 0.75rem;
      font-weight: 700;
      min-width: 20px;
      height: 20px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .alert-panel {
      position: fixed;
      bottom: 6rem;
      right: 2rem;
      width: 380px;
      max-height: 500px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      z-index: 99;
      transform: translateY(20px);
      opacity: 0;
      pointer-events: none;
      transition: transform 0.3s, opacity 0.3s;
      overflow: hidden;
    }

    .alert-panel.visible {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }

    .alert-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    .alert-panel-title {
      font-weight: 600;
      font-size: 1rem;
    }

    .alert-panel-close {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      color: var(--text-muted);
      transition: color 0.2s;
    }

    .alert-panel-close:hover {
      color: var(--text-primary);
    }

    .alert-panel-tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
    }

    .alert-tab {
      flex: 1;
      padding: 0.75rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      transition: all 0.2s;
    }

    .alert-tab.active {
      color: var(--color-blue);
      border-bottom: 2px solid var(--color-blue);
    }

    .alert-tab:hover:not(.active) {
      color: var(--text-primary);
      background: var(--bg-card-hover);
    }

    .alert-panel-content {
      max-height: 350px;
      overflow-y: auto;
    }

    .alert-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.875rem 1rem;
      border-bottom: 1px solid var(--border-color);
      transition: background 0.2s;
    }

    .alert-item:hover {
      background: var(--bg-card-hover);
    }

    .alert-item:last-child {
      border-bottom: none;
    }

    .alert-item-icon {
      font-size: 1.25rem;
    }

    .alert-item.info .alert-item-icon { color: #60a5fa; }
    .alert-item.warning .alert-item-icon { color: #fbbf24; }
    .alert-item.critical .alert-item-icon { color: #ef4444; }

    .alert-item-content {
      flex: 1;
    }

    .alert-item-title {
      font-weight: 500;
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
    }

    .alert-item-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .alert-item-dismiss {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 1rem;
      padding: 0.25rem;
      transition: color 0.2s;
    }

    .alert-item-dismiss:hover {
      color: var(--text-primary);
    }

    .alert-config-section {
      padding: 1rem;
    }

    .alert-config-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .alert-toggle-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid var(--border-color);
    }

    .alert-toggle-item:last-child {
      border-bottom: none;
    }

    .alert-toggle-label {
      font-size: 0.875rem;
    }

    .alert-toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .alert-toggle.active {
      background: var(--color-blue);
    }

    .alert-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.2s;
    }

    .alert-toggle.active::after {
      transform: translateX(20px);
    }

    .alert-empty {
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
    }

    /* Anomaly Indicator */
    .metric-card.anomalous {
      border-color: #f59e0b;
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.2);
    }

    .metric-card.anomalous::before {
      content: '‚ö†Ô∏è Anomaly Detected';
      display: block;
      font-size: 0.7rem;
      color: #f59e0b;
      font-weight: 600;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
    }

    .anomaly-badge {
      display: inline-block;
      background: #f59e0b;
      color: #000;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 600;
      margin-left: 0.5rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        gap: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      .charts-section {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Spinner -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="spinner"></div>
  </div>

  <div class="header">
    <h1>ü§ñ Agent Metrics Dashboard</h1>
    <div class="header-actions">
      <button class="export-btn" id="export-btn" title="Export to CSV">
        üì• Export CSV
      </button>
      <button class="theme-toggle" id="theme-toggle" title="Toggle theme">
        üåô
      </button>
    </div>
  </div>
  
  <div class="dashboard">
    <div class="metric-card">
      <div class="metric-header">
        <div>
          <div class="metric-label">Active Sessions</div>
          <span class="comparison-badge" id="sessions-comparison"></span>
        </div>
        <div class="trend-indicator trend-up" id="sessions-trend">‚Üë 0%</div>
      </div>
      <div class="metric-value" id="active-sessions">--</div>
      <div class="metric-footer">Current running agent sessions</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-header">
        <div>
          <div class="metric-label">Tasks Completed</div>
          <span class="comparison-badge" id="tasks-comparison"></span>
        </div>
        <div class="trend-indicator trend-up" id="tasks-trend">‚Üë 0%</div>
      </div>
      <div class="metric-value" id="total-tasks">--</div>
      <div class="metric-footer">Total tasks processed</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-header">
        <div>
          <div class="metric-label">Active Agents</div>
          <span class="comparison-badge" id="agents-comparison"></span>
        </div>
        <div class="trend-indicator trend-neutral" id="agents-trend">‚Üí 0%</div>
      </div>
      <div class="metric-value" id="agent-count">--</div>
      <div class="metric-footer">Registered agents</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-header">
        <div class="metric-label">Server Uptime</div>
        <div class="trend-indicator trend-up" id="uptime-trend">‚Üë 0%</div>
      </div>
      <div class="metric-value" id="uptime">--</div>
      <div class="metric-footer">Dashboard running time</div>
    </div>
  </div>
  
  <div class="charts-section">
    <!-- Line Chart: Tasks over time -->
    <div class="chart-card">
      <div class="chart-title">üìà Tasks Completed (Last 24 Hours)</div>
      <svg class="line-chart" id="tasks-line-chart" viewBox="0 0 300 150">
        <defs>
          <linearGradient id="lineGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:var(--color-blue);stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:var(--color-blue);stop-opacity:0" />
          </linearGradient>
        </defs>
      </svg>
    </div>
    
    <!-- Heatmap: Hourly activity -->
    <div class="chart-card">
      <div class="chart-title">üóìÔ∏è Activity Heatmap (Hourly)</div>
      <div class="heatmap" id="activity-heatmap"></div>
    </div>
    
    <!-- Bar Chart: Agent workload -->
    <div class="chart-card">
      <div class="chart-title">üë• Agent Workload Distribution</div>
      <div class="bar-chart" id="workload-bar-chart"></div>
    </div>
  </div>
  
  <div class="last-updated">
    <span id="gateway-status" class="gateway-indicator"></span>
    <span id="mock-notice"></span>
    Last updated: <span id="last-updated">--</span>
  </div>

  <!-- Alert Banner -->
  <div class="alert-banner" id="alert-banner">
    <span class="alert-icon"></span>
    <span class="alert-message"></span>
    <button class="alert-dismiss" onclick="dismissAlertBanner()">√ó</button>
  </div>

  <!-- Alert Panel Toggle -->
  <button class="alert-panel-toggle" id="alert-panel-toggle" onclick="toggleAlertPanel()">
    üîî
    <span class="alert-badge" id="alert-badge" style="display: none;">0</span>
  </button>

  <!-- Alert Panel -->
  <div class="alert-panel" id="alert-panel">
    <div class="alert-panel-header">
      <span class="alert-panel-title">Alerts</span>
      <button class="alert-panel-close" onclick="toggleAlertPanel()">√ó</button>
    </div>
    <div class="alert-panel-tabs">
      <button class="alert-tab active" data-tab="active" onclick="switchAlertTab('active')">Active</button>
      <button class="alert-tab" data-tab="history" onclick="switchAlertTab('history')">History</button>
      <button class="alert-tab" data-tab="config" onclick="switchAlertTab('config')">‚öôÔ∏è</button>
    </div>
    <div class="alert-panel-content" id="alert-panel-content">
      <!-- Alert items populated by JS -->
    </div>
  </div>

  <script>
    // Historical data storage with timestamps
    const historicalData = {
      sessions: [],
      tasks: [],
      agents: [],
      last24h: [] // Store all metrics with timestamps
    };

    // Alert system state
    const alertState = {
      activeAlerts: [],
      alertHistory: [],
      config: {
        activeSessionsThreshold: 5,
        tasksCompletedZeroMinutes: 60,
        enabled: {
          activeSessions: true,
          tasksCompleted: true,
          anomalyDetection: true
        }
      },
      dismissedBanner: false,
      currentTab: 'active'
    };

    // Anomaly detection state
    const anomalyState = {
      baselines: {
        tasks: { values: [], avg: 0, std: 0 }
      },
      anomalies: {}
    };

    // Previous day's totals for comparison
    let yesterdayTotals = null;
    let previousMetrics = null;
    
    // Initialize historical data
    function initHistoricalData() {
      const now = Date.now();
      // Generate mock last 24 hours of data
      for (let i = 23; i >= 0; i--) {
        const timestamp = now - i * 3600000;
        historicalData.last24h.push({
          timestamp: new Date(timestamp).toISOString(),
          activeSessions: Math.floor(Math.random() * 5) + 1,
          totalTasks: Math.floor(Math.random() * 20) + 5,
          agentCount: 3
        });
      }
      // Generate mock yesterday's total
      yesterdayTotals = {
        activeSessions: Math.floor(Math.random() * 5) + 2,
        totalTasks: Math.floor(Math.random() * 100) + 50,
        agentCount: 3
      };
    }

    // Store metric in historical data
    function storeMetric(data) {
      const entry = {
        timestamp: data.timestamp || new Date().toISOString(),
        activeSessions: data.activeSessions,
        totalTasks: data.totalTasks,
        agentCount: data.agentCount
      };
      
      historicalData.last24h.push(entry);
      
      // Keep only last 24 hours
      const cutoff = Date.now() - 24 * 3600000;
      historicalData.last24h = historicalData.last24h.filter(e => new Date(e.timestamp).getTime() > cutoff);
      
      historicalData.sessions.push(data.activeSessions);
      historicalData.tasks.push(data.totalTasks);
      historicalData.agents.push(data.agentCount);
      
      // Keep last 48 entries for trend calculation
      if (historicalData.sessions.length > 48) historicalData.sessions.shift();
      if (historicalData.tasks.length > 48) historicalData.tasks.shift();
      if (historicalData.agents.length > 48) historicalData.agents.shift();
    }

    // Calculate yesterday comparison
    function getYesterdayComparison(current, yesterday) {
      if (!yesterday) return { value: 0, direction: 'neutral', text: '' };
      
      const change = current - yesterday;
      const percentChange = yesterday > 0 ? ((change / yesterday) * 100).toFixed(0) : 0;
      
      let direction = 'neutral';
      let text = 'Same';
      
      if (change > 0) {
        direction = 'positive';
        text = `+${percentChange}% vs yesterday`;
      } else if (change < 0) {
        direction = 'negative';
        text = `${percentChange}% vs yesterday`;
      }
      
      return { value: change, direction, text };
    }

    // Theme management
    function initTheme() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      document.documentElement.setAttribute('data-theme', savedTheme);
      document.getElementById('theme-toggle').textContent = savedTheme === 'light' ? 'üåô' : '‚òÄÔ∏è';
    }

    function toggleTheme() {
      const current = document.documentElement.getAttribute('data-theme');
      const next = current === 'light' ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      document.getElementById('theme-toggle').textContent = next === 'light' ? 'üåô' : '‚òÄÔ∏è';
    }

    // Export to CSV
    function exportToCSV() {
      const headers = ['Timestamp', 'Active Sessions', 'Tasks Completed', 'Agent Count'];
      const rows = historicalData.last24h.map(entry => [
        entry.timestamp,
        entry.activeSessions,
        entry.totalTasks,
        entry.agentCount
      ]);

      // Add summary totals
      const totals = historicalData.last24h.reduce((acc, curr) => ({
        sessions: acc.sessions + curr.activeSessions,
        tasks: acc.tasks + curr.totalTasks,
        agents: Math.max(acc.agents, curr.agentCount)
      }), { sessions: 0, tasks: 0, agents: 0 });

      let csvContent = 'data:text/csv;charset=utf-8,';
      csvContent += headers.join(',') + '\n';
      rows.forEach(row => {
        csvContent += row.join(',') + '\n';
      });

      // Add summary section
      csvContent += '\nSummary (Last 24 Hours)\n';
      csvContent += `Total Sessions,${totals.sessions}\n`;
      csvContent += `Total Tasks,${totals.tasks}\n`;
      csvContent += `Peak Agents,${totals.agents}\n`;
      csvContent += `Exported At,${new Date().toISOString()}\n`;

      const encodedUri = encodeURI(csvContent);
      const link = document.createElement('a');
      link.setAttribute('href', encodedUri);
      link.setAttribute('download', `agent-metrics-${new Date().toISOString().split('T')[0]}.csv`);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Generate heatmap data (7 days x 24 hours)
    function generateHeatmapData() {
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const data = [];
      const today = new Date().getDay();
      
      for (let d = 0; d < 7; d++) {
        const dayData = { day: days[(today - 6 + d + 7) % 7], hours: [] };
        for (let h = 0; h < 24; h++) {
          // Simulate higher activity during work hours
          let intensity = Math.random();
          if (h >= 9 && h <= 17) intensity *= 2;
          if (d === today - 1 || d === today) intensity *= 1.5;
          dayData.hours.push(Math.min(1, intensity));
        }
        data.push(dayData);
      }
      return data;
    }

    // Generate workload distribution data
    function generateWorkloadData() {
      return [
        { agent: 'Delta', tasks: Math.floor(Math.random() * 20) + 10, color: '#60a5fa' },
        { agent: 'Zero', tasks: Math.floor(Math.random() * 15) + 8, color: '#34d399' },
        { agent: 'Alpha', tasks: Math.floor(Math.random() * 12) + 5, color: '#f472b6' },
        { agent: 'Beta', tasks: Math.floor(Math.random() * 10) + 3, color: '#fbbf24' }
      ];
    }

    function formatUptime(seconds) {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      if (hrs > 0) return `${hrs}h ${mins}m`;
      if (mins > 0) return `${mins}m ${secs}s`;
      return `${secs}s`;
    }

    function calculateTrend(current, previous) {
      if (!previous || previous.length < 2) return { value: 0, direction: 'neutral' };
      const prev = previous[previous.length - 2] || current;
      if (prev === 0) return { value: 0, direction: 'neutral' };
      const change = ((current - prev) / prev) * 100;
      return {
        value: Math.abs(change).toFixed(0),
        direction: change > 0 ? 'up' : change < 0 ? 'down' : 'neutral'
      };
    }

    function updateTrendIndicator(id, trend) {
      const el = document.getElementById(id);
      el.className = `trend-indicator trend-${trend.direction}`;
      const arrow = trend.direction === 'up' ? '‚Üë' : trend.direction === 'down' ? '‚Üì' : '‚Üí';
      el.textContent = `${arrow} ${trend.value}%`;
    }

    function updateComparisonBadge(id, comparison) {
      const el = document.getElementById(id);
      el.className = `comparison-badge ${comparison.direction}`;
      el.textContent = comparison.text;
    }

    function renderLineChart(data) {
      const svg = document.getElementById('tasks-line-chart');
      const width = 300, height = 150;
      const padding = { top: 10, right: 10, bottom: 25, left: 30 };
      
      const maxVal = Math.max(...data.map(d => d.totalTasks), 10);
      const points = data.map((d, i) => {
        const x = padding.left + (i / (data.length - 1)) * (width - padding.left - padding.right);
        const y = height - padding.bottom - (d.totalTasks / maxVal) * (height - padding.top - padding.bottom);
        return `${x},${y}`;
      });
      
      // Get CSS variable
      const style = getComputedStyle(document.documentElement);
      const blueColor = style.getPropertyValue('--color-blue').trim() || '#60a5fa';
      
      let html = `
        <defs>
          <linearGradient id="lineGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:${blueColor};stop-opacity:0.3" />
            <stop offset="100%" style="stop-color:${blueColor};stop-opacity:0" />
          </linearGradient>
        </defs>
      `;
      
      // Grid lines
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (i / 4) * (height - padding.top - padding.bottom);
        html += `<line class="grid-line" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`;
      }
      
      // Area fill
      const areaPoints = `${padding.left},${height - padding.bottom} ` + points.join(' ') + `,${width - padding.right},${height - padding.bottom}`;
      html += `<path class="area" d="M ${areaPoints}"/>`;
      
      // Line
      html += `<path d="M ${points.join(' L ')}"/>`;
      
      // Dots with tooltips
      points.forEach((p, i) => {
        const [x, y] = p.split(',');
        if (i % 4 === 0) {
          const tooltip = `Tasks: ${data[i].totalTasks}, Time: ${new Date(data[i].timestamp).toLocaleTimeString()}`;
          html += `<circle class="dot" cx="${x}" cy="${y}" r="4" data-tooltip="${tooltip}"/>`;
        }
      });
      
      // X-axis labels
      data.forEach((d, i) => {
        if (i % 6 === 0) {
          const x = padding.left + (i / (data.length - 1)) * (width - padding.left - padding.right);
          const hour = new Date(d.timestamp).getHours();
          html += `<text class="axis-label" x="${x}" y="${height - 5}" text-anchor="middle">${hour}h</text>`;
        }
      });
      
      svg.innerHTML = html;
    }

    function renderHeatmap(data) {
      const container = document.getElementById('activity-heatmap');
      let html = `<div class="heatmap-label"><span>12am</span><span>6am</span><span>12pm</span><span>6pm</span><span>11pm</span></div>`;
      
      data.forEach(row => {
        html += `<div class="heatmap-day">${row.day}</div>`;
        row.hours.forEach((intensity, h) => {
          const color = intensity > 0.7 ? '#34d399' : intensity > 0.4 ? '#60a5fa' : intensity > 0.2 ? '#334155' : '#1e293b';
          const opacity = 0.3 + intensity * 0.7;
          html += `<div class="heatmap-cell" style="background: ${color}; opacity: ${opacity}" data-tooltip="${(intensity * 100).toFixed(0)}% activity - Hour ${h}"></div>`;
        });
      });
      
      container.innerHTML = html;
    }

    function renderBarChart(data) {
      const container = document.getElementById('workload-bar-chart');
      const maxVal = Math.max(...data.map(d => d.tasks));
      let html = '';
      
      data.forEach(d => {
        const height = (d.tasks / maxVal) * 80;
        html += `
          <div class="bar-group">
            <div class="bar-value">${d.tasks}</div>
            <div class="bar" style="height: ${height}px; background: ${d.color}; animation-delay: ${Math.random() * 0.3}s" data-tooltip="${d.tasks} tasks"></div>
            <div class="bar-label">${d.agent}</div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    async function fetchMetrics() {
      try {
        const res = await fetch('/api/metrics');
        const data = await res.json();
        
        // Store in historical data
        storeMetric(data);
        
        // Update metric values with animation
        const cards = document.querySelectorAll('.metric-card');
        cards.forEach(card => {
          card.classList.add('updating');
          setTimeout(() => card.classList.remove('updating'), 300);
        });
        
        document.getElementById('active-sessions').textContent = data.activeSessions;
        document.getElementById('total-tasks').textContent = data.totalTasks;
        document.getElementById('agent-count').textContent = data.agentCount;
        document.getElementById('uptime').textContent = formatUptime(data.uptime);
        
        // Update trends
        if (historicalData.sessions.length > 1) {
          updateTrendIndicator('sessions-trend', calculateTrend(data.activeSessions, historicalData.sessions));
          updateTrendIndicator('tasks-trend', calculateTrend(data.totalTasks, historicalData.tasks));
          updateTrendIndicator('agents-trend', calculateTrend(data.agentCount, historicalData.agents));
        }
        
        // Update yesterday comparison
        updateComparisonBadge('sessions-comparison', getYesterdayComparison(data.activeSessions, yesterdayTotals?.activeSessions));
        updateComparisonBadge('tasks-comparison', getYesterdayComparison(data.totalTasks, yesterdayTotals?.totalTasks));
        updateComparisonBadge('agents-comparison', getYesterdayComparison(data.agentCount, yesterdayTotals?.agentCount));
        
        previousMetrics = { ...data };
        
        const now = new Date();
        document.getElementById('last-updated').textContent = now.toLocaleTimeString();
        
        // Update gateway status indicator
        const gatewayStatus = document.getElementById('gateway-status');
        if (data.gatewayConnected) {
          gatewayStatus.className = 'gateway-indicator connected';
          gatewayStatus.textContent = 'GATEWAY';
          document.getElementById('mock-notice').innerHTML = '';
        } else {
          gatewayStatus.className = 'gateway-indicator disconnected';
          gatewayStatus.textContent = 'OFFLINE';
          if (data.mock) {
            document.getElementById('mock-notice').innerHTML = '<span class="mock-badge">MOCK DATA</span>';
          }
        }

        // Update charts with historical data
        renderLineChart(historicalData.last24h);
      } catch (error) {
        console.error('Failed to fetch metrics:', error);
        // Show error state
        const gatewayStatus = document.getElementById('gateway-status');
        gatewayStatus.className = 'gateway-indicator error';
        gatewayStatus.textContent = 'ERROR';
      }
    }

    // Initialize
    initHistoricalData();
    initTheme();
    
    // Theme toggle
    document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
    
    // Export button
    document.getElementById('export-btn').addEventListener('click', exportToCSV);
    
    // Initial render
    renderLineChart(historicalData.last24h);
    renderHeatmap(generateHeatmapData());
    renderBarChart(generateWorkloadData());
    
    // Initial fetch
    fetchMetrics();
    
    // Hide loading spinner
    setTimeout(() => {
      document.getElementById('loading-overlay').classList.add('hidden');
    }, 500);
    
    // Refresh every 10 seconds
    setInterval(fetchMetrics, 10000);
    
    // Refresh charts every 30 seconds
    setInterval(() => {
      renderHeatmap(generateHeatmapData());
      renderBarChart(generateWorkloadData());
    }, 30000);

    // ==================== ALERT SYSTEM ====================

    // Calculate rolling baseline for anomaly detection
    function updateAnomalyBaseline() {
      const tasks = historicalData.last24h.map(d => d.totalTasks);
      if (tasks.length < 10) return;
      
      const values = tasks.slice(-20); // Use last 20 data points
      const sum = values.reduce((a, b) => a + b, 0);
      const avg = sum / values.length;
      const variance = values.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / values.length;
      const std = Math.sqrt(variance);
      
      anomalyState.baselines.tasks = { values, avg, std };
    }

    // Check for anomalies
    function checkAnomaly(metric, value) {
      const baseline = anomalyState.baselines[metric];
      if (!baseline || baseline.std === 0) return false;
      
      const deviation = Math.abs(value - baseline.avg) / baseline.std;
      return deviation > 2; // More than 2 standard deviations
    }

    // Add alert
    function addAlert(type, severity, title, message, metadata = {}) {
      const alert = {
        id: Date.now() + Math.random(),
        type,
        severity,
        title,
        message,
        timestamp: new Date().toISOString(),
        metadata,
        dismissed: false
      };
      
      // Check if similar alert already active
      const existing = alertState.activeAlerts.find(a => a.type === type && !a.dismissed);
      if (existing) return; // Don't duplicate
      
      alertState.activeAlerts.push(alert);
      alertState.alertHistory.unshift(alert);
      
      // Keep only last 100 in history
      if (alertState.alertHistory.length > 100) {
        alertState.alertHistory = alertState.alertHistory.slice(0, 100);
      }
      
      updateAlertUI();
      
      // Send browser notification for critical alerts
      if (severity === 'critical') {
        sendBrowserNotification(title, message);
      }
    }

    // Dismiss alert
    function dismissAlert(alertId) {
      const alert = alertState.activeAlerts.find(a => a.id === alertId);
      if (alert) {
        alert.dismissed = true;
        alertState.activeAlerts = alertState.activeAlerts.filter(a => a.id !== alertId);
        updateAlertUI();
      }
    }

    // Check thresholds and generate alerts
    function checkThresholds(data) {
      // Active sessions threshold
      if (alertState.config.enabled.activeSessions && data.activeSessions > alertState.config.activeSessionsThreshold) {
        addAlert('activeSessions', 'warning', 'High Active Sessions', 
          `${data.activeSessions} active sessions (threshold: ${alertState.config.activeSessionsThreshold})`,
          { value: data.activeSessions, threshold: alertState.config.activeSessionsThreshold }
        );
      }
      
      // Check for zero tasks completed in threshold period
      const oneHourAgo = Date.now() - alertState.config.tasksCompletedZeroMinutes * 60000;
      const recentTasks = historicalData.last24h.filter(e => new Date(e.timestamp).getTime() > oneHourAgo);
      const tasksLastHour = recentTasks.reduce((sum, e) => sum + e.totalTasks, 0);
      
      if (alertState.config.enabled.tasksCompleted && tasksLastHour === 0 && historicalData.last24h.length > 2) {
        addAlert('tasksCompleted', 'critical', 'No Tasks Completed', 
          `Zero tasks completed in the last ${alertState.config.tasksCompletedZeroMinutes} minutes`,
          { value: 0, threshold: alertState.config.tasksCompletedZeroMinutes }
        );
      }
    }

    // Update anomaly indicators on cards
    function updateAnomalyIndicators(data) {
      anomalyState.anomalies = {};
      
      if (alertState.config.enabled.anomalyDetection) {
        updateAnomalyBaseline();
        
        // Check sessions anomaly
        if (checkAnomaly('tasks', data.totalTasks)) {
          anomalyState.anomalies.tasks = true;
        }
      }
    }

    // Show alert banner
    function showAlertBanner(severity, message) {
      if (alertState.dismissedBanner) return;
      
      const banner = document.getElementById('alert-banner');
      const icon = banner.querySelector('.alert-icon');
      const msgEl = banner.querySelector('.alert-message');
      
      banner.className = `alert-banner ${severity}`;
      
      if (severity === 'critical') {
        icon.textContent = 'üö®';
      } else if (severity === 'warning') {
        icon.textContent = '‚ö†Ô∏è';
      } else {
        icon.textContent = '‚ÑπÔ∏è';
      }
      
      msgEl.textContent = message;
      banner.classList.add('visible');
    }

    // Dismiss alert banner
    function dismissAlertBanner() {
      const banner = document.getElementById('alert-banner');
      banner.classList.remove('visible');
      alertState.dismissedBanner = true;
      
      // Reset after 5 minutes
      setTimeout(() => {
        alertState.dismissedBanner = false;
      }, 300000);
    }

    // Toggle alert panel
    function toggleAlertPanel() {
      const panel = document.getElementById('alert-panel');
      panel.classList.toggle('visible');
    }

    // Switch alert tab
    function switchAlertTab(tab) {
      alertState.currentTab = tab;
      
      document.querySelectorAll('.alert-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.tab === tab);
      });
      
      updateAlertUI();
    }

    // Update alert UI
    function updateAlertUI() {
      const content = document.getElementById('alert-panel-content');
      const badge = document.getElementById('alert-badge');
      
      // Update badge count
      const activeCount = alertState.activeAlerts.filter(a => !a.dismissed).length;
      badge.textContent = activeCount;
      badge.style.display = activeCount > 0 ? 'flex' : 'none';
      
      if (alertState.currentTab === 'active') {
        renderActiveAlerts(content);
      } else if (alertState.currentTab === 'history') {
        renderAlertHistory(content);
      } else if (alertState.currentTab === 'config') {
        renderAlertConfig(content);
      }
    }

    // Render active alerts
    function renderActiveAlerts(container) {
      const active = alertState.activeAlerts.filter(a => !a.dismissed);
      
      if (active.length === 0) {
        container.innerHTML = '<div class="alert-empty">‚úÖ No active alerts</div>';
        return;
      }
      
      let html = '';
      active.forEach(alert => {
        const icon = alert.severity === 'critical' ? 'üö®' : alert.severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
        const time = new Date(alert.timestamp).toLocaleTimeString();
        html += `
          <div class="alert-item ${alert.severity}">
            <span class="alert-item-icon">${icon}</span>
            <div class="alert-item-content">
              <div class="alert-item-title">${alert.title}</div>
              <div class="alert-item-meta">${alert.message} ‚Ä¢ ${time}</div>
            </div>
            <button class="alert-item-dismiss" onclick="dismissAlert(${alert.id})">√ó</button>
          </div>
        `;
      });
      container.innerHTML = html;
    }

    // Render alert history
    function renderAlertHistory(container) {
      const history = alertState.alertHistory.slice(0, 20);
      
      if (history.length === 0) {
        container.innerHTML = '<div class="alert-empty">No alert history</div>';
        return;
      }
      
      let html = '';
      history.forEach(alert => {
        const icon = alert.severity === 'critical' ? 'üö®' : alert.severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
        const time = new Date(alert.timestamp).toLocaleString();
        html += `
          <div class="alert-item ${alert.severity}">
            <span class="alert-item-icon">${icon}</span>
            <div class="alert-item-content">
              <div class="alert-item-title">${alert.title}</div>
              <div class="alert-item-meta">${alert.message} ‚Ä¢ ${time}</div>
            </div>
          </div>
        `;
      });
      container.innerHTML = html;
    }

    // Render alert configuration
    function renderAlertConfig(container) {
      const cfg = alertState.config;
      container.innerHTML = `
        <div class="alert-config-section">
          <div class="alert-config-title">Alert Thresholds</div>
          <div class="alert-toggle-item">
            <span class="alert-toggle-label">Active Sessions > ${cfg.activeSessionsThreshold}</span>
            <div class="alert-toggle ${cfg.enabled.activeSessions ? 'active' : ''}" 
                 onclick="toggleAlertConfig('activeSessions')"></div>
          </div>
          <div class="alert-toggle-item">
            <span class="alert-toggle-label">Tasks = 0 for ${cfg.tasksCompletedZeroMinutes}min</span>
            <div class="alert-toggle ${cfg.enabled.tasksCompleted ? 'active' : ''}" 
                 onclick="toggleAlertConfig('tasksCompleted')"></div>
          </div>
          <div class="alert-toggle-item">
            <span class="alert-toggle-label">Anomaly Detection</span>
            <div class="alert-toggle ${cfg.enabled.anomalyDetection ? 'active' : ''}" 
                 onclick="toggleAlertConfig('anomalyDetection')"></div>
          </div>
        </div>
      `;
    }

    // Toggle alert config
    function toggleAlertConfig(key) {
      alertState.config.enabled[key] = !alertState.config.enabled[key];
      updateAlertUI();
    }

    // Request browser notification permission
    async function requestNotificationPermission() {
      if (!('Notification' in window)) return;
      
      if (Notification.permission === 'default') {
        await Notification.requestPermission();
      }
    }

    // Send browser notification
    function sendBrowserNotification(title, body) {
      if (!('Notification' in window) || Notification.permission !== 'granted') return;
      
      const notification = new Notification(title, {
        body,
        icon: 'ü§ñ',
        tag: 'agent-metrics-alert',
        requireInteraction: true
      });
      
      notification.onclick = () => {
        window.focus();
        notification.close();
      };
    }

    // Update anomaly card styling
    function updateCardAnomalyStyling() {
      const cards = document.querySelectorAll('.metric-card');
      
      cards.forEach((card, index) => {
        card.classList.remove('anomalous');
        const existingBadge = card.querySelector('.anomaly-badge');
        if (existingBadge) existingBadge.remove();
      });
      
      // Check tasks card (index 1)
      if (anomalyState.anomalies.tasks) {
        const tasksCard = cards[1];
        if (tasksCard) {
          tasksCard.classList.add('anomalous');
          const label = tasksCard.querySelector('.metric-label');
          if (label) {
            const badge = document.createElement('span');
            badge.className = 'anomaly-badge';
            badge.textContent = '‚ö†Ô∏è Anomaly';
            label.appendChild(badge);
          }
        }
      }
    }

    // Modified fetchMetrics to include alert checking
    const originalFetchMetrics = fetchMetrics;
    fetchMetrics = async function() {
      try {
        const res = await fetch('/api/metrics');
        const data = await res.json();
        
        // Store in historical data
        storeMetric(data);
        
        // Update metric values with animation
        const cards = document.querySelectorAll('.metric-card');
        cards.forEach(card => {
          card.classList.add('updating');
          setTimeout(() => card.classList.remove('updating'), 300);
        });
        
        document.getElementById('active-sessions').textContent = data.activeSessions;
        document.getElementById('total-tasks').textContent = data.totalTasks;
        document.getElementById('agent-count').textContent = data.agentCount;
        document.getElementById('uptime').textContent = formatUptime(data.uptime);
        
        // Update trends
        if (historicalData.sessions.length > 1) {
          updateTrendIndicator('sessions-trend', calculateTrend(data.activeSessions, historicalData.sessions));
          updateTrendIndicator('tasks-trend', calculateTrend(data.totalTasks, historicalData.tasks));
          updateTrendIndicator('agents-trend', calculateTrend(data.agentCount, historicalData.agents));
        }
        
        // Update yesterday comparison
        updateComparisonBadge('sessions-comparison', getYesterdayComparison(data.activeSessions, yesterdayTotals?.activeSessions));
        updateComparisonBadge('tasks-comparison', getYesterdayComparison(data.totalTasks, yesterdayTotals?.totalTasks));
        updateComparisonBadge('agents-comparison', getYesterdayComparison(data.agentCount, yesterdayTotals?.agentCount));
        
        previousMetrics = { ...data };
        
        const now = new Date();
        document.getElementById('last-updated').textContent = now.toLocaleTimeString();
        
        // Update gateway status indicator
        const gatewayStatus = document.getElementById('gateway-status');
        if (data.gatewayConnected) {
          gatewayStatus.className = 'gateway-indicator connected';
          gatewayStatus.textContent = 'GATEWAY';
          document.getElementById('mock-notice').innerHTML = '';
        } else {
          gatewayStatus.className = 'gateway-indicator disconnected';
          gatewayStatus.textContent = 'OFFLINE';
          if (data.mock) {
            document.getElementById('mock-notice').innerHTML = '<span class="mock-badge">MOCK DATA</span>';
          }
        }

        // Update charts with historical data
        renderLineChart(historicalData.last24h);
        
        // ===== ALERT SYSTEM CHECKS =====
        checkThresholds(data);
        updateAnomalyIndicators(data);
        updateCardAnomalyStyling();
        
        // Show banner for highest severity alert
        const criticalAlert = alertState.activeAlerts.find(a => a.severity === 'critical' && !a.dismissed);
        const warningAlert = alertState.activeAlerts.find(a => a.severity === 'warning' && !a.dismissed);
        
        if (criticalAlert) {
          showAlertBanner('critical', criticalAlert.message);
        } else if (warningAlert && !alertState.dismissedBanner) {
          showAlertBanner('warning', warningAlert.message);
        } else {
          document.getElementById('alert-banner').classList.remove('visible');
        }
        
      } catch (error) {
        console.error('Failed to fetch metrics:', error);
      }
    };

    // Initialize alert UI
    updateAlertUI();
    
    // Request notification permission on first interaction
    document.addEventListener('click', function initNotifications() {
      requestNotificationPermission();
      document.removeEventListener('click', initNotifications);
    }, { once: true });

  </script>
</body>
</html>
